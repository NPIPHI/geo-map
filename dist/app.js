/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./ts/main.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/earcut/src/earcut.js":
/*!*******************************************!*\
  !*** ./node_modules/earcut/src/earcut.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = earcut;\nmodule.exports.default = earcut;\n\nfunction earcut(data, holeIndices, dim) {\n\n    dim = dim || 2;\n\n    var hasHoles = holeIndices && holeIndices.length,\n        outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n        outerNode = linkedList(data, 0, outerLen, dim, true),\n        triangles = [];\n\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n    var minX, minY, maxX, maxY, x, y, invSize;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n\n        for (var i = dim; i < outerLen; i += dim) {\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 1 / invSize : 0;\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    var i, last;\n\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n    } else {\n        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    var p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n    var stop = ear,\n        prev, next;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        prev = ear.prev;\n        next = ear.next;\n\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim);\n            triangles.push(ear.i / dim);\n            triangles.push(next.i / dim);\n\n            removeNode(ear);\n\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n            // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    var p = ear.next.next;\n\n    while (p !== ear.prev) {\n        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // triangle bbox; min & max are calculated like this for speed\n    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),\n        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),\n        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),\n        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);\n\n    // z-order range for the current triangle bbox;\n    var minZ = zOrder(minTX, minTY, minX, minY, invSize),\n        maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);\n\n    var p = ear.prevZ,\n        n = ear.nextZ;\n\n    // look for points inside the triangle in both directions\n    while (p && p.z >= minZ && n && n.z <= maxZ) {\n        if (p !== ear.prev && p !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n\n        if (n !== ear.prev && n !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\n            area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    // look for remaining points in decreasing z-order\n    while (p && p.z >= minZ) {\n        if (p !== ear.prev && p !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    // look for remaining points in increasing z-order\n    while (n && n.z <= maxZ) {\n        if (n !== ear.prev && n !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\n            area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i / dim);\n            triangles.push(p.i / dim);\n            triangles.push(b.i / dim);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, invSize);\n                earcutLinked(c, triangles, dim, minX, minY, invSize);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [],\n        i, len, start, end, list;\n\n    for (i = 0, len = holeIndices.length; i < len; i++) {\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareX);\n\n    // process holes from left to right\n    for (i = 0; i < queue.length; i++) {\n        eliminateHole(queue[i], outerNode);\n        outerNode = filterPoints(outerNode, outerNode.next);\n    }\n\n    return outerNode;\n}\n\nfunction compareX(a, b) {\n    return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n    outerNode = findHoleBridge(hole, outerNode);\n    if (outerNode) {\n        var b = splitPolygon(outerNode, hole);\n\n        // filter collinear points around the cuts\n        filterPoints(outerNode, outerNode.next);\n        filterPoints(b, b.next);\n    }\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    var p = outerNode,\n        hx = hole.x,\n        hy = hole.y,\n        qx = -Infinity,\n        m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                if (x === hx) {\n                    if (hy === p.y) return p;\n                    if (hy === p.next.y) return p.next;\n                }\n                m = p.x < p.next.x ? p : p.next;\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    var stop = m,\n        mx = m.x,\n        my = m.y,\n        tanMin = Infinity,\n        tan;\n\n    p = m;\n\n    do {\n        if (hx >= p.x && p.x >= mx && hx !== p.x &&\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if (locallyInside(p, hole) &&\n                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    } while (p !== stop);\n\n    return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n    var p = start;\n    do {\n        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize,\n        inSize = 1;\n\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for (i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = 32767 * (x - minX) * invSize;\n    y = 32767 * (y - minY) * invSize;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    var p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&\n           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&\n           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges\n           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    var o1 = sign(area(p1, q1, p2));\n    var o2 = sign(area(p1, q1, q2));\n    var o3 = sign(area(p2, q2, p1));\n    var o4 = sign(area(p2, q2, q1));\n\n    if (o1 !== o2 && o3 !== o4) return true; // general case\n\n    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n    return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\n\nfunction sign(num) {\n    return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n                intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    var p = a,\n        inside = false,\n        px = (a.x + b.x) / 2,\n        py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    var a2 = new Node(a.i, a.x, a.y),\n        b2 = new Node(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    var p = new Node(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n    // vertex index in coordinates array\n    this.i = i;\n\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n\n    // previous and next vertex nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n\n    // z-order curve value\n    this.z = null;\n\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nearcut.deviation = function (data, holeIndices, dim, triangles) {\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (var i = 0, len = holeIndices.length; i < len; i++) {\n            var start = holeIndices[i] * dim;\n            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    var trianglesArea = 0;\n    for (i = 0; i < triangles.length; i += 3) {\n        var a = triangles[i] * dim;\n        var b = triangles[i + 1] * dim;\n        var c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\n\nfunction signedArea(data, start, end, dim) {\n    var sum = 0;\n    for (var i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nearcut.flatten = function (data) {\n    var dim = data[0][0].length,\n        result = {vertices: [], holes: [], dimensions: dim},\n        holeIndex = 0;\n\n    for (var i = 0; i < data.length; i++) {\n        for (var j = 0; j < data[i].length; j++) {\n            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);\n        }\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n};\n\n\n//# sourceURL=webpack:///./node_modules/earcut/src/earcut.js?");

/***/ }),

/***/ "./node_modules/point-in-polygon/index.js":
/*!************************************************!*\
  !*** ./node_modules/point-in-polygon/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function (point, vs) {\n    // ray-casting algorithm based on\n    // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n    \n    var x = point[0], y = point[1];\n    \n    var inside = false;\n    for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {\n        var xi = vs[i][0], yi = vs[i][1];\n        var xj = vs[j][0], yj = vs[j][1];\n        \n        var intersect = ((yi > y) != (yj > y))\n            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n        if (intersect) inside = !inside;\n    }\n    \n    return inside;\n};\n\n\n//# sourceURL=webpack:///./node_modules/point-in-polygon/index.js?");

/***/ }),

/***/ "./ts/bufferConstructor.ts":
/*!*********************************!*\
  !*** ./ts/bufferConstructor.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst main_1 = __webpack_require__(/*! ./main */ \"./ts/main.ts\");\r\nconst earcut_1 = __importDefault(__webpack_require__(/*! earcut */ \"./node_modules/earcut/src/earcut.js\"));\r\nconst memory_1 = __webpack_require__(/*! ./memory */ \"./ts/memory.ts\");\r\nfunction buffer(array) {\r\n    let buf = main_1.gl.createBuffer();\r\n    main_1.gl.bindBuffer(main_1.gl.ARRAY_BUFFER, buf);\r\n    main_1.gl.bufferData(main_1.gl.ARRAY_BUFFER, array, main_1.gl.STATIC_DRAW);\r\n    return buf;\r\n}\r\nclass bufferConstructor {\r\n    static lineBuffer(pointStrips) {\r\n        let length = 0;\r\n        pointStrips.forEach(strip => {\r\n            length += strip.length * 2;\r\n        });\r\n        let GPUMemoryOffsets = new Int32Array(length);\r\n        let GPUMemoryWidths = new Int32Array(length);\r\n        let featureIndex = 0;\r\n        let vertexArray = new Float32Array(length * 2);\r\n        let attribIndex = 0;\r\n        pointStrips.forEach(strip => {\r\n            GPUMemoryOffsets[featureIndex] = attribIndex;\r\n            GPUMemoryWidths[featureIndex] = 2 * strip.length;\r\n            for (let i = 0; i < strip.length - 1; i += 2) {\r\n                vertexArray[attribIndex] = strip[i];\r\n                vertexArray[attribIndex + 1] = strip[i + 1];\r\n                vertexArray[attribIndex + 2] = strip[i + 2];\r\n                vertexArray[attribIndex + 3] = strip[i + 3];\r\n                attribIndex += 4;\r\n            }\r\n            vertexArray[attribIndex] = strip[strip.length - 2];\r\n            vertexArray[attribIndex + 1] = strip[strip.length - 1];\r\n            vertexArray[attribIndex + 2] = strip[0];\r\n            vertexArray[attribIndex + 3] = strip[1];\r\n            attribIndex += 4;\r\n            featureIndex++;\r\n        });\r\n        let vertexBuffer = buffer(vertexArray);\r\n        let colorArray = new Float32Array(length * 3);\r\n        for (let i = 0; i < colorArray.length; i += 3) {\r\n            colorArray[i] = 1;\r\n            colorArray[i + 1] = 1;\r\n            colorArray[i + 2] = 1;\r\n        }\r\n        let colorBuffer = buffer(colorArray);\r\n        return { buffer: memory_1.GPUBufferSet.createFromBuffers([2 * 4, 3 * 4], [vertexBuffer, colorBuffer], length), features: { offsets: GPUMemoryOffsets, widths: GPUMemoryWidths } };\r\n    }\r\n    static polygonBuffer(pointStrips) {\r\n        let buffer = memory_1.GPUBufferSet.create([8, 4]);\r\n        let features = bufferConstructor.inPlacePolygonBuffer(pointStrips, buffer);\r\n        return { buffer, features };\r\n    }\r\n    static outlineBuffer(pointStrips) {\r\n        let buffer = memory_1.GPUBufferSet.create([8, 8, 4]);\r\n        let features = bufferConstructor.inPlaceOutlineBuffer(pointStrips, buffer);\r\n        return { buffer, features };\r\n    }\r\n    static inPlaceOutlineBuffer(pointStrips, target) {\r\n        let length = pointStrips.reduce((length, strip) => length + strip.length + 4, 0);\r\n        let GPUMemoryOffsets = new Int32Array(pointStrips.length);\r\n        let GPUMemoryWidths = new Int32Array(pointStrips.length);\r\n        let vertexArray = new Float32Array(length * 2);\r\n        let normalArray = new Float32Array(length * 2);\r\n        let styleArray = new Int32Array(length);\r\n        let memoryOffset = target.head;\r\n        let featureIndex = 0;\r\n        let attribIndex = 0;\r\n        pointStrips.forEach(strip => {\r\n            GPUMemoryOffsets[featureIndex] = attribIndex + memoryOffset;\r\n            GPUMemoryWidths[featureIndex] = strip.length + 4;\r\n            let startAttribIndex = attribIndex;\r\n            attribIndex += 1;\r\n            for (let i = 0; i < strip.length + 1; i += 2) {\r\n                let prevX = strip[(i - 2 + strip.length) % strip.length];\r\n                let prevY = strip[(i - 1 + strip.length) % strip.length];\r\n                let curX = strip[i % strip.length];\r\n                let curY = strip[(i + 1) % strip.length];\r\n                let nextX = strip[(i + 2) % strip.length];\r\n                let nextY = strip[(i + 3) % strip.length];\r\n                vertexArray[attribIndex * 2] = curX;\r\n                vertexArray[attribIndex * 2 + 1] = curY;\r\n                vertexArray[attribIndex * 2 + 2] = curX;\r\n                vertexArray[attribIndex * 2 + 3] = curY;\r\n                prevX = curX - prevX;\r\n                prevY = curY - prevY;\r\n                nextX = curX - nextX;\r\n                nextY = curY - nextY;\r\n                let prevMag = Math.sqrt(prevX * prevX + prevY * prevY);\r\n                let nextMag = Math.sqrt(nextX * nextX + nextY * nextY);\r\n                prevX /= prevMag;\r\n                prevY /= prevMag;\r\n                nextX /= nextMag;\r\n                nextY /= nextMag;\r\n                let normX = prevX + nextX;\r\n                let normY = prevY + nextY;\r\n                let normMag = Math.sqrt(normX * normX + normY * normY);\r\n                if (normMag < 0.001) {\r\n                    normX = -prevY;\r\n                    normY = prevX;\r\n                }\r\n                else {\r\n                    normX /= normMag;\r\n                    normY /= normMag;\r\n                    let normDot = Math.abs(normX * -prevY + normY * prevX);\r\n                    normDot = Math.max(normDot, 0.5);\r\n                    normX /= normDot;\r\n                    normY /= normDot;\r\n                }\r\n                if (normX * -prevY + normY * prevX < 0) {\r\n                    normX *= -1;\r\n                    normY *= -1;\r\n                }\r\n                normalArray[attribIndex * 2] = 0;\r\n                normalArray[attribIndex * 2 + 1] = 0;\r\n                normalArray[attribIndex * 2 + 2] = -normX;\r\n                normalArray[attribIndex * 2 + 3] = -normY;\r\n                attribIndex += 2;\r\n            }\r\n            vertexArray[startAttribIndex * 2] = vertexArray[startAttribIndex * 2 + 2];\r\n            vertexArray[startAttribIndex * 2 + 1] = vertexArray[startAttribIndex * 2 + 3];\r\n            normalArray[startAttribIndex * 2] = normalArray[startAttribIndex * 2 + 2];\r\n            normalArray[startAttribIndex * 2 + 1] = normalArray[startAttribIndex * 2 + 3];\r\n            vertexArray[attribIndex * 2] = vertexArray[attribIndex * 2 - 2];\r\n            vertexArray[attribIndex * 2 + 1] = vertexArray[attribIndex * 2 - 1];\r\n            normalArray[attribIndex * 2] = normalArray[attribIndex * 2 - 2];\r\n            normalArray[attribIndex * 2 + 1] = normalArray[attribIndex * 2 - 1];\r\n            attribIndex += 1;\r\n            featureIndex++;\r\n        });\r\n        target.addRaw([vertexArray, normalArray, styleArray]);\r\n        return { offsets: GPUMemoryOffsets, widths: GPUMemoryWidths };\r\n    }\r\n    static inPlacePolygonBuffer(pointStrips, target) {\r\n        let polygonIndexBuffer = [];\r\n        let length = 0;\r\n        pointStrips.forEach(strip => {\r\n            let polygon = earcut_1.default(strip);\r\n            polygonIndexBuffer.push(polygon);\r\n            length += polygon.length;\r\n        });\r\n        let GPUMemoryOffsets = new Int32Array(pointStrips.length);\r\n        let GPUMemoryWidths = new Int32Array(pointStrips.length);\r\n        let vertexArray = new Float32Array(length * 2);\r\n        let styleArray = new Int32Array(length);\r\n        let memoryOffset = target.head;\r\n        let featureIndex = 0;\r\n        let attribIndex = 0;\r\n        for (let i = 0; i < polygonIndexBuffer.length; i++) {\r\n            GPUMemoryOffsets[featureIndex] = attribIndex + memoryOffset;\r\n            GPUMemoryWidths[featureIndex] = polygonIndexBuffer[i].length;\r\n            for (let j = 0; j < polygonIndexBuffer[i].length; j += 3) {\r\n                let v1 = polygonIndexBuffer[i][j];\r\n                let v2 = polygonIndexBuffer[i][j + 1];\r\n                let v3 = polygonIndexBuffer[i][j + 2];\r\n                vertexArray[attribIndex * 2 + 0] = pointStrips[i][v1 * 2 + 0];\r\n                vertexArray[attribIndex * 2 + 1] = pointStrips[i][v1 * 2 + 1];\r\n                vertexArray[attribIndex * 2 + 2] = pointStrips[i][v2 * 2 + 0];\r\n                vertexArray[attribIndex * 2 + 3] = pointStrips[i][v2 * 2 + 1];\r\n                vertexArray[attribIndex * 2 + 4] = pointStrips[i][v3 * 2 + 0];\r\n                vertexArray[attribIndex * 2 + 5] = pointStrips[i][v3 * 2 + 1];\r\n                attribIndex += 3;\r\n            }\r\n            featureIndex++;\r\n        }\r\n        target.addRaw([vertexArray, styleArray]);\r\n        return { offsets: GPUMemoryOffsets, widths: GPUMemoryWidths };\r\n    }\r\n}\r\nexports.bufferConstructor = bufferConstructor;\r\nclass featureConstructor {\r\n    static lineBuffer(strip) {\r\n        let length = strip.length * 2;\r\n        let vertexArray = new Float32Array(length * 2);\r\n        let colorArray = new Float32Array(length * 3);\r\n        let index = 0;\r\n        for (let i = 0; i < strip.length - 1; i += 2) {\r\n            vertexArray[index] = strip[i];\r\n            vertexArray[index + 1] = strip[i + 1];\r\n            vertexArray[index + 2] = strip[i + 2];\r\n            vertexArray[index + 3] = strip[i + 3];\r\n            index += 4;\r\n        }\r\n        vertexArray[index] = strip[strip.length - 2];\r\n        vertexArray[index + 1] = strip[strip.length - 1];\r\n        vertexArray[index + 2] = strip[0];\r\n        vertexArray[index + 3] = strip[1];\r\n        index += 4;\r\n        for (let i = 0; i < colorArray.length; i += 3) {\r\n            colorArray[i] = 1;\r\n            colorArray[i + 1] = 1;\r\n            colorArray[i + 2] = 1;\r\n        }\r\n        return new memory_1.GPUMemoryObject(length, [vertexArray, colorArray]);\r\n    }\r\n    static polygonBuffer(strip) {\r\n        let polygonIndexBuffer = earcut_1.default(strip);\r\n        let length = polygonIndexBuffer.length;\r\n        let vertexArray = new Float32Array(length * 2);\r\n        let styleArray = new Float32Array(length);\r\n        let vIndex = 0;\r\n        let cIndex = 0;\r\n        for (let i = 0; i < polygonIndexBuffer.length; i += 3) {\r\n            let v1 = polygonIndexBuffer[i];\r\n            let v2 = polygonIndexBuffer[i + 1];\r\n            let v3 = polygonIndexBuffer[i + 2];\r\n            vertexArray[vIndex + 0] = strip[v1 * 2 + 0];\r\n            vertexArray[vIndex + 1] = strip[v1 * 2 + 1];\r\n            vertexArray[vIndex + 2] = strip[v2 * 2 + 0];\r\n            vertexArray[vIndex + 3] = strip[v2 * 2 + 1];\r\n            vertexArray[vIndex + 4] = strip[v3 * 2 + 0];\r\n            vertexArray[vIndex + 5] = strip[v3 * 2 + 1];\r\n            vIndex += 6;\r\n            for (let i = 0; i < 3; i++) {\r\n                styleArray[cIndex + i] = 0;\r\n            }\r\n            cIndex += 3;\r\n        }\r\n        return new memory_1.GPUMemoryObject(length, [vertexArray, styleArray]);\r\n    }\r\n    static outlineBuffer(strip) {\r\n        let length = strip.length + 4;\r\n        let vertexArray = new Float32Array(length * 2);\r\n        let normalArray = new Float32Array(length * 2);\r\n        let styleArray = new Int32Array(length);\r\n        let vIndex = 0;\r\n        let nIndex = 0;\r\n        let cIndex = 0;\r\n        vIndex += 2;\r\n        nIndex += 2;\r\n        cIndex += 3;\r\n        for (let i = 0; i < strip.length + 1; i += 2) {\r\n            let prevX = strip[(i - 2 + strip.length) % strip.length];\r\n            let prevY = strip[(i - 1 + strip.length) % strip.length];\r\n            let curX = strip[i % strip.length];\r\n            let curY = strip[(i + 1) % strip.length];\r\n            let nextX = strip[(i + 2) % strip.length];\r\n            let nextY = strip[(i + 3) % strip.length];\r\n            vertexArray[vIndex] = curX;\r\n            vertexArray[vIndex + 1] = curY;\r\n            vertexArray[vIndex + 2] = curX;\r\n            vertexArray[vIndex + 3] = curY;\r\n            vIndex += 4;\r\n            prevX = curX - prevX;\r\n            prevY = curY - prevY;\r\n            nextX = curX - nextX;\r\n            nextY = curY - nextY;\r\n            let prevMag = Math.sqrt(prevX * prevX + prevY * prevY);\r\n            let nextMag = Math.sqrt(nextX * nextX + nextY * nextY);\r\n            prevX /= prevMag;\r\n            prevY /= prevMag;\r\n            nextX /= nextMag;\r\n            nextY /= nextMag;\r\n            let normX = prevX + nextX;\r\n            let normY = prevY + nextY;\r\n            let normMag = Math.sqrt(normX * normX + normY * normY);\r\n            if (normMag < 0.001) {\r\n                normX = -prevY;\r\n                normY = prevX;\r\n            }\r\n            else {\r\n                normX /= normMag;\r\n                normY /= normMag;\r\n                let normDot = Math.abs(normX * -prevY + normY * prevX);\r\n                normDot = Math.max(normDot, 0.5);\r\n                normX /= normDot;\r\n                normY /= normDot;\r\n            }\r\n            if (normX * -prevY + normY * prevX < 0) {\r\n                normX *= -1;\r\n                normY *= -1;\r\n            }\r\n            normalArray[nIndex] = normX;\r\n            normalArray[nIndex + 1] = normY;\r\n            normalArray[nIndex + 2] = -normX;\r\n            normalArray[nIndex + 3] = -normY;\r\n            nIndex += 4;\r\n            cIndex += 2;\r\n        }\r\n        vertexArray[0] = vertexArray[2];\r\n        vertexArray[1] = vertexArray[3];\r\n        normalArray[0] = normalArray[2];\r\n        normalArray[1] = normalArray[3];\r\n        vertexArray[vIndex] = vertexArray[vIndex - 2];\r\n        vertexArray[vIndex + 1] = vertexArray[vIndex - 1];\r\n        normalArray[nIndex] = normalArray[nIndex - 2];\r\n        normalArray[nIndex + 1] = normalArray[nIndex - 1];\r\n        return new memory_1.GPUMemoryObject(length, [vertexArray, normalArray, styleArray]);\r\n    }\r\n}\r\nexports.featureConstructor = featureConstructor;\r\n\n\n//# sourceURL=webpack:///./ts/bufferConstructor.ts?");

/***/ }),

/***/ "./ts/camera.ts":
/*!**********************!*\
  !*** ./ts/camera.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nlet aespectRatio = 1;\r\nclass camera extends Float32Array {\r\n    static getView(x, y, scaleX, scaleY) {\r\n        let arr = new Float32Array(9);\r\n        arr[0] = scaleX / aespectRatio;\r\n        arr[4] = scaleY;\r\n        arr[6] = x * scaleX / aespectRatio;\r\n        arr[7] = y * scaleY;\r\n        return arr;\r\n    }\r\n    static setAespectRatio(width, height) {\r\n        aespectRatio = width / height;\r\n    }\r\n    static toWorldSpace(x, y, cam, canvas) {\r\n        return { x: (x / canvas.width - 0.5) * canvas.width / canvas.height * 2 / cam.scaleX - cam.x, y: (-y / canvas.height + 0.5) * 2 / cam.scaleY - cam.y };\r\n    }\r\n}\r\nexports.camera = camera;\r\n\n\n//# sourceURL=webpack:///./ts/camera.ts?");

/***/ }),

/***/ "./ts/feature.ts":
/*!***********************!*\
  !*** ./ts/feature.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst bufferConstructor_1 = __webpack_require__(/*! ./bufferConstructor */ \"./ts/bufferConstructor.ts\");\r\nconst kdTree_1 = __webpack_require__(/*! ./kdTree */ \"./ts/kdTree.ts\");\r\nclass Feature {\r\n    constructor(strip, id, outline, polygon) {\r\n        this.id = id;\r\n        this.bBox = kdTree_1.boundingBox.fromStrip(strip);\r\n        this.outline = outline;\r\n        this.polygon = polygon;\r\n        this.shape = strip;\r\n    }\r\n    static fromPointStrip(strip, id) {\r\n        return new Feature(strip, id, bufferConstructor_1.featureConstructor.outlineBuffer(strip), bufferConstructor_1.featureConstructor.polygonBuffer(strip));\r\n    }\r\n}\r\nexports.Feature = Feature;\r\n\n\n//# sourceURL=webpack:///./ts/feature.ts?");

/***/ }),

/***/ "./ts/kdTree.ts":
/*!**********************!*\
  !*** ./ts/kdTree.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst point_in_polygon_1 = __importDefault(__webpack_require__(/*! point-in-polygon */ \"./node_modules/point-in-polygon/index.js\"));\r\nclass boundingBox {\r\n    constructor(x1, y1, x2, y2) {\r\n        this.x1 = x1;\r\n        this.x2 = x2;\r\n        this.y1 = y1;\r\n        this.y2 = y2;\r\n    }\r\n    static fromStrip(points) {\r\n        let x1;\r\n        let x2;\r\n        let y1;\r\n        let y2;\r\n        x1 = x2 = points[0];\r\n        y1 = y2 = points[1];\r\n        for (let i = 0; i < points.length; i += 2) {\r\n            x1 = Math.min(x1, points[i]);\r\n            x2 = Math.max(x2, points[i]);\r\n            y1 = Math.min(y1, points[i + 1]);\r\n            y2 = Math.max(y2, points[i + 1]);\r\n        }\r\n        return new boundingBox(x1, y1, x2, y2);\r\n    }\r\n    contains(x, y) {\r\n        return x > this.x1 && x < this.x2 && y > this.y1 && y < this.y2;\r\n    }\r\n    intesects(bBox) {\r\n        return bBox.x1 <= this.x2 && this.x1 <= bBox.x2 && bBox.y1 <= this.y2 && this.y1 <= bBox.y2;\r\n    }\r\n}\r\nexports.boundingBox = boundingBox;\r\nclass KDHeep {\r\n    constructor(elements, bBox, depth = 1) {\r\n    }\r\n}\r\nexports.KDHeep = KDHeep;\r\nclass KDTree {\r\n    constructor(elements, bBox, recursiveDepth = 8) {\r\n        this.topNode = new KDNode(elements, bBox, recursiveDepth, true);\r\n    }\r\n    static async buildAsync(elements, bBox, recursiveDepth = 8) {\r\n        return new Promise((resolve, reject) => {\r\n            let tree = new KDTree(elements, bBox, recursiveDepth);\r\n            resolve(tree);\r\n        });\r\n    }\r\n    find(x, y) {\r\n        let returnList = [];\r\n        this.topNode.find(x, y, returnList);\r\n        return returnList;\r\n    }\r\n    findSelection(bBox) {\r\n        let returnList = [];\r\n        this.topNode.findSelection(bBox, returnList);\r\n        return returnList;\r\n    }\r\n    popFirst(x, y) {\r\n        return this.topNode.popFirst(x, y);\r\n    }\r\n    insert(element) {\r\n        if (this.topNode.bBox.intesects(element.bBox)) {\r\n            this.topNode.insert(element);\r\n        }\r\n        else {\r\n            throw (\"feature outsied of tree\");\r\n        }\r\n    }\r\n}\r\nexports.KDTree = KDTree;\r\nclass KDNode {\r\n    constructor(elements, bBox, recursiveDepth, splitDirection) {\r\n        this.bBox = bBox;\r\n        if (recursiveDepth !== 0) {\r\n            let node1Box;\r\n            let node2Box;\r\n            let node1Elements = [];\r\n            let node2Elements = [];\r\n            this.elements = [];\r\n            if (splitDirection) {\r\n                node1Box = new boundingBox(bBox.x1, bBox.y1, (bBox.x2 + bBox.x1) / 2, bBox.y2);\r\n                node2Box = new boundingBox((bBox.x2 + bBox.x1) / 2, bBox.y1, bBox.x2, bBox.y2);\r\n            }\r\n            else {\r\n                node1Box = new boundingBox(bBox.x1, bBox.y1, bBox.x2, (bBox.y2 + bBox.y1) / 2);\r\n                node2Box = new boundingBox(bBox.x1, (bBox.y2 + bBox.y1) / 2, bBox.x2, bBox.y2);\r\n            }\r\n            elements.forEach(ele => {\r\n                let inNode1 = ele.bBox.intesects(node1Box);\r\n                let inNode2 = ele.bBox.intesects(node2Box);\r\n                if (inNode1 && inNode2) {\r\n                    this.elements.push(ele);\r\n                }\r\n                else if (inNode1) {\r\n                    node1Elements.push(ele);\r\n                }\r\n                else if (inNode2) {\r\n                    node2Elements.push(ele);\r\n                }\r\n                else {\r\n                    throw (\"element was not in bounding box\");\r\n                }\r\n            });\r\n            this.node1 = new KDNode(node1Elements, node1Box, recursiveDepth - 1, !splitDirection);\r\n            this.node2 = new KDNode(node2Elements, node2Box, recursiveDepth - 1, !splitDirection);\r\n        }\r\n        else {\r\n            this.elements = elements;\r\n        }\r\n    }\r\n    insert(element) {\r\n        let inNode1 = !!this.node1 && element.bBox.intesects(this.node1.bBox);\r\n        let inNode2 = !!this.node2 && element.bBox.intesects(this.node2.bBox);\r\n        if (inNode1 && inNode2) {\r\n            this.elements.push(element);\r\n        }\r\n        else if (inNode1) {\r\n            this.node1.insert(element);\r\n        }\r\n        else if (inNode2) {\r\n            this.node2.insert(element);\r\n        }\r\n        else {\r\n            this.elements.push(element);\r\n        }\r\n    }\r\n    find(x, y, returnList) {\r\n        for (let i = 0; i < this.elements.length; i++) {\r\n            if (this.elements[i].bBox.contains(x, y)) {\r\n                if (this.inShape(this.elements[i].shape, x, y)) {\r\n                    returnList.push(this.elements[i]);\r\n                }\r\n            }\r\n        }\r\n        if (this.node1 && this.node1.bBox.contains(x, y)) {\r\n            this.node1.find(x, y, returnList);\r\n        }\r\n        if (this.node2 && this.node2.bBox.contains(x, y)) {\r\n            this.node2.find(x, y, returnList);\r\n        }\r\n    }\r\n    findSelection(bBox, returnList) {\r\n        for (let i = 0; i < this.elements.length; i++) {\r\n            if (this.elements[i].bBox.intesects(bBox)) {\r\n                returnList.push(this.elements[i]);\r\n            }\r\n        }\r\n        if (this.node1 && this.node1.bBox.intesects(bBox)) {\r\n            this.node1.findSelection(bBox, returnList);\r\n        }\r\n        if (this.node2 && this.node2.bBox.intesects(bBox)) {\r\n            this.node2.findSelection(bBox, returnList);\r\n        }\r\n    }\r\n    popFirst(x, y) {\r\n        for (let i = 0; i < this.elements.length; i++) {\r\n            if (this.elements[i].bBox.contains(x, y)) {\r\n                return this.elements.splice(i, 1)[0];\r\n            }\r\n        }\r\n        if (this.node1 && this.node1.bBox.contains(x, y)) {\r\n            return this.node1.popFirst(x, y);\r\n        }\r\n        if (this.node2 && this.node2.bBox.contains(x, y)) {\r\n            return this.node2.popFirst(x, y);\r\n        }\r\n    }\r\n    inShape(shape, x, y) {\r\n        return point_in_polygon_1.default([x, y], this.asPointArray(shape));\r\n    }\r\n    asPointArray(shape) {\r\n        let ret = [];\r\n        for (let i = 0; i < shape.length; i += 2) {\r\n            ret.push([shape[i], shape[i + 1]]);\r\n        }\r\n        return ret;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./ts/kdTree.ts?");

/***/ }),

/***/ "./ts/main.ts":
/*!********************!*\
  !*** ./ts/main.ts ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst renderer_1 = __webpack_require__(/*! ./renderer */ \"./ts/renderer.ts\");\r\nconst camera_1 = __webpack_require__(/*! ./camera */ \"./ts/camera.ts\");\r\nconst mapLoad_1 = __webpack_require__(/*! ./mapLoad */ \"./ts/mapLoad.ts\");\r\nconst kdTree_1 = __webpack_require__(/*! ./kdTree */ \"./ts/kdTree.ts\");\r\nvar renderer;\r\nvar canvas;\r\nvar map;\r\nvar cam = { x: 0, y: 0, scaleX: 1, scaleY: 1 };\r\nvar baseCam = { x: 0, y: 0 };\r\nvar mouse = { x: 0, y: 0, down: false };\r\nvar invalidated = false;\r\nvar drawParams = { lines: true, polygons: true };\r\nvar paintMode = false;\r\nfunction sizeCanvas() {\r\n    canvas.width = canvas.getBoundingClientRect().width;\r\n    canvas.height = canvas.getBoundingClientRect().height;\r\n    camera_1.camera.setAespectRatio(canvas.width, canvas.height);\r\n    exports.gl.viewport(0, 0, canvas.width, canvas.height);\r\n    invalidate();\r\n}\r\nfunction init() {\r\n    if (window.sessionStorage.getItem(\"VIEW\")) {\r\n        cam = JSON.parse(window.sessionStorage.getItem(\"VIEW\"));\r\n        baseCam = { x: cam.x, y: cam.y };\r\n    }\r\n    canvas = document.createElement(\"canvas\");\r\n    exports.gl = canvas.getContext(\"webgl2\");\r\n    document.body.appendChild(canvas);\r\n    sizeCanvas();\r\n    renderer = new renderer_1.mapRenderer(exports.gl);\r\n    map = mapLoad_1.loadMapChuncks(\"./chuncks\");\r\n    window.onload = loop;\r\n}\r\nfunction invalidate() {\r\n    invalidated = true;\r\n}\r\nexports.invalidate = invalidate;\r\nfunction setFeatureNumberDisplay(featureNumber) {\r\n    document.getElementById(\"TileNumber\").innerHTML = featureNumber;\r\n}\r\nexports.setFeatureNumberDisplay = setFeatureNumberDisplay;\r\nfunction setHoveredElement(id) {\r\n    document.getElementById(\"HoveredElement\").innerHTML = id;\r\n}\r\nexports.setHoveredElement = setHoveredElement;\r\nlet lastState = {};\r\nfunction manageSidebar() {\r\n    let state = {};\r\n    let lower = document.getElementById(\"lower\").value;\r\n    let upper = document.getElementById(\"upper\").value;\r\n    let lowerBound = state.lower = Math.exp(parseFloat(lower));\r\n    let upperBound = state.upper = Math.exp(parseFloat(upper));\r\n    renderer.setTransitionBoundry(lowerBound, upperBound);\r\n    document.getElementById(\"ZoomLevel\").innerHTML = Math.log(cam.scaleX).toFixed(1);\r\n    state.lines = drawParams.lines = document.getElementById(\"lines\").checked;\r\n    state.polygons = drawParams.polygons = document.getElementById(\"polygons\").checked;\r\n    paintMode = document.getElementById(\"paint\").checked;\r\n    if (lastState.lower != state.lower || lastState.upper != state.upper || lastState.lines != state.lines || lastState.polygons != state.polygons) {\r\n        state = lastState;\r\n        invalidate();\r\n    }\r\n}\r\nfunction loop() {\r\n    manageSidebar();\r\n    if (invalidated) {\r\n        renderer.clear();\r\n        renderer.renderMap(map, camera_1.camera.getView(cam.x, cam.y, cam.scaleY, cam.scaleY), drawParams.polygons, drawParams.lines);\r\n        invalidated = false;\r\n    }\r\n    requestAnimationFrame(loop);\r\n}\r\ninit();\r\nwindow.addEventListener(\"resize\", sizeCanvas);\r\ncanvas.addEventListener(\"wheel\", mouse => {\r\n    let zoom = Math.pow(1.01, -mouse.deltaY);\r\n    cam.scaleX *= zoom;\r\n    cam.scaleY *= zoom;\r\n    invalidate();\r\n    window.sessionStorage.setItem(\"VIEW\", JSON.stringify(cam));\r\n});\r\ncanvas.addEventListener(\"pointerdown\", pointer => {\r\n    if (pointer.button === 0) {\r\n        mouse.down = true;\r\n        mouse.x = pointer.offsetX;\r\n        mouse.y = pointer.offsetY;\r\n        cam.x = baseCam.x + (pointer.offsetX - mouse.x) * 2 / 1000 / cam.scaleX;\r\n        cam.y = baseCam.y - (pointer.offsetY - mouse.y) * 2 / 1000 / cam.scaleY;\r\n    }\r\n    else if (pointer.button === 2) {\r\n        let start = performance.now();\r\n        let adjustedPointer = camera_1.camera.toWorldSpace(pointer.x, pointer.y, cam, canvas);\r\n        map.setStyle(map.select(adjustedPointer.x, adjustedPointer.y), 2);\r\n        console.log(`selecting and styling 1 feature took ${performance.now() - start} ms`);\r\n        invalidate();\r\n    }\r\n    else {\r\n        let start = performance.now();\r\n        let adjustedPointer = camera_1.camera.toWorldSpace(pointer.x, pointer.y, cam, canvas);\r\n        map.remove(adjustedPointer.x, adjustedPointer.y);\r\n        console.log(`selecting and removing 1 feature took ${performance.now() - start} ms`);\r\n        invalidate();\r\n    }\r\n});\r\ncanvas.addEventListener(\"contextmenu\", (e) => { e.preventDefault(); return false; });\r\ncanvas.addEventListener(\"pointerup\", pointer => {\r\n    if (pointer.button === 0) {\r\n        mouse.down = false;\r\n        baseCam = { x: cam.x, y: cam.y };\r\n        window.sessionStorage.setItem(\"VIEW\", JSON.stringify(cam));\r\n    }\r\n});\r\ncanvas.addEventListener(\"pointermove\", pointer => {\r\n    if (mouse.down) {\r\n        cam.x = baseCam.x + (pointer.offsetX - mouse.x) * 2 / 1000 / cam.scaleY;\r\n        cam.y = baseCam.y - (pointer.offsetY - mouse.y) * 2 / 1000 / cam.scaleX;\r\n        invalidate();\r\n    }\r\n    if (paintMode) {\r\n        let adjustedPointer = camera_1.camera.toWorldSpace(pointer.x, pointer.y, cam, canvas);\r\n        let time1 = performance.now();\r\n        let selection = map.selectRectangle(new kdTree_1.boundingBox(adjustedPointer.x - 0.1, adjustedPointer.y - 0.1, adjustedPointer.x + 0.1, adjustedPointer.y + 0.1));\r\n        selection.forEach(ele => {\r\n            map.setStyle(ele, 2);\r\n        });\r\n        console.log(`Selecting ${selection.length} elements took ${performance.now() - time1} miliseconds`);\r\n        invalidate();\r\n    }\r\n    let adjustedPointer = camera_1.camera.toWorldSpace(pointer.x, pointer.y, cam, canvas);\r\n    let selected = map.select(adjustedPointer.x, adjustedPointer.y);\r\n    if (selected) {\r\n        setHoveredElement(selected.id);\r\n    }\r\n    else {\r\n        setHoveredElement(\"none\");\r\n    }\r\n});\r\n\n\n//# sourceURL=webpack:///./ts/main.ts?");

/***/ }),

/***/ "./ts/map.ts":
/*!*******************!*\
  !*** ./ts/map.ts ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst feature_1 = __webpack_require__(/*! ./feature */ \"./ts/feature.ts\");\r\nconst memory_1 = __webpack_require__(/*! ./memory */ \"./ts/memory.ts\");\r\nconst bufferConstructor_1 = __webpack_require__(/*! ./bufferConstructor */ \"./ts/bufferConstructor.ts\");\r\nconst kdTree_1 = __webpack_require__(/*! ./kdTree */ \"./ts/kdTree.ts\");\r\nconst main_1 = __webpack_require__(/*! ./main */ \"./ts/main.ts\");\r\nclass mapLayer {\r\n    constructor(pointStrips, ids) {\r\n        this.featureCount = 0;\r\n        let outlineData = bufferConstructor_1.bufferConstructor.outlineBuffer(pointStrips);\r\n        let polygonData = bufferConstructor_1.bufferConstructor.polygonBuffer(pointStrips);\r\n        this.outlines = outlineData.buffer;\r\n        this.polygons = polygonData.buffer;\r\n        let features = [];\r\n        for (let i = 0; i < pointStrips.length; i++) {\r\n            features.push(new feature_1.Feature(pointStrips[i], ids[i], new memory_1.GPUMemoryPointer(outlineData.features.offsets[i], outlineData.features.widths[i]), new memory_1.GPUMemoryPointer(polygonData.features.offsets[i], polygonData.features.widths[i])));\r\n        }\r\n        this.featureTree = new kdTree_1.KDTree([], new kdTree_1.boundingBox(0, 0, 4, 4));\r\n    }\r\n    addFeatures(pointStrips, ids) {\r\n        this.featureCount += pointStrips.length;\r\n        main_1.setFeatureNumberDisplay(this.featureCount);\r\n        let outlineMemoryPointers = bufferConstructor_1.bufferConstructor.inPlaceOutlineBuffer(pointStrips, this.outlines);\r\n        let polygonMemoryPointers = bufferConstructor_1.bufferConstructor.inPlacePolygonBuffer(pointStrips, this.polygons);\r\n        for (let i = 0; i < outlineMemoryPointers.offsets.length; i++) {\r\n            this.featureTree.insert(new feature_1.Feature(pointStrips[i], ids[i], new memory_1.GPUMemoryPointer(outlineMemoryPointers.offsets[i], outlineMemoryPointers.widths[i]), new memory_1.GPUMemoryPointer(polygonMemoryPointers.offsets[i], polygonMemoryPointers.widths[i])));\r\n        }\r\n    }\r\n    select(x, y) {\r\n        return this.featureTree.find(x, y)[0];\r\n    }\r\n    selectRectangle(bBox) {\r\n        return this.featureTree.findSelection(bBox);\r\n    }\r\n    remove(x, y) {\r\n        let removed = this.featureTree.popFirst(x, y);\r\n        if (removed) {\r\n            this.polygons.remove(removed.polygon);\r\n            this.outlines.remove(removed.outline);\r\n        }\r\n        else {\r\n            console.warn(\"No feature in selected location\");\r\n        }\r\n    }\r\n    setStyle(feature, style) {\r\n        if (feature === undefined) {\r\n            console.warn(\"feature was undefined\");\r\n            return;\r\n        }\r\n        let styleData = new Int32Array(feature.outline.GPUWidth);\r\n        for (let i = 0; i < styleData.length; i++) {\r\n            styleData[i] = style;\r\n        }\r\n        if (feature.outline instanceof memory_1.GPUMemoryPointer) {\r\n            feature.outline = feature.outline.toMemoryObject([new Float32Array(), new Float32Array(), styleData]);\r\n        }\r\n        else {\r\n            feature.outline.GPUData[2] = styleData;\r\n        }\r\n        this.outlines.update(feature.outline, 2);\r\n        styleData = new Int32Array(feature.polygon.GPUWidth);\r\n        for (let i = 0; i < styleData.length; i++) {\r\n            styleData[i] = style;\r\n        }\r\n        if (feature.polygon instanceof memory_1.GPUMemoryPointer) {\r\n            feature.polygon = feature.polygon.toMemoryObject([new Float32Array(), styleData]);\r\n        }\r\n        else {\r\n            feature.polygon.GPUData[1] = styleData;\r\n        }\r\n        this.polygons.update(feature.polygon, 1);\r\n    }\r\n}\r\nexports.mapLayer = mapLayer;\r\n\n\n//# sourceURL=webpack:///./ts/map.ts?");

/***/ }),

/***/ "./ts/mapLoad.ts":
/*!***********************!*\
  !*** ./ts/mapLoad.ts ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst map_1 = __webpack_require__(/*! ./map */ \"./ts/map.ts\");\r\nconst main_1 = __webpack_require__(/*! ./main */ \"./ts/main.ts\");\r\nconst bbox = { minx: 6429499.583465844, miny: 1797629.5004901737, maxx: 6446651.559660509, maxy: 1805369.9351405054 };\r\nasync function loadMap() {\r\n    let file = await fetch(\"../mapData/output.buf\");\r\n    let buffer = await file.arrayBuffer();\r\n    let mapData = await (await fetch(\"../mapData/output.json\")).json();\r\n    let pointArray = new Float32Array(buffer);\r\n    let pointPaths = [];\r\n    let idList = [];\r\n    mapData.shapes.forEach((shape) => {\r\n        pointPaths.push(pointArray.slice(shape[1], shape[1] + shape[2] * 2 - 2));\r\n        idList.push(shape[0]);\r\n    });\r\n    return { points: pointPaths, ids: idList };\r\n}\r\nexports.loadMap = loadMap;\r\nasync function parseMapJson(path = \"../mapData/slabs.json\") {\r\n    let rawData = await fetch(path);\r\n    let jsonData = await rawData.json();\r\n    let pointPaths = [];\r\n    let idList = [];\r\n    let xRescale = 1 / (bbox.maxx - bbox.minx);\r\n    let yRescale = 1 / (bbox.maxx - bbox.minx);\r\n    let xOffset = bbox.minx;\r\n    let yOffset = bbox.miny;\r\n    jsonData.forEach((slab) => {\r\n        let points = slab.geometry.coordinates[0][0];\r\n        let strip = new Float32Array(points.length * 2 - 2);\r\n        for (let i = 0; i < points.length - 1; i++) {\r\n            strip[i * 2] = (points[i][0] - xOffset) * xRescale;\r\n            strip[i * 2 + 1] = (points[i][1] - yOffset) * yRescale;\r\n        }\r\n        idList.push(slab.properties.BRANCH_ID + \"-\" + slab.properties.SECTION_ID + \"-\" + slab.properties.postgis_id);\r\n        pointPaths.push(strip);\r\n    });\r\n    return { points: pointPaths, ids: idList };\r\n}\r\nexports.parseMapJson = parseMapJson;\r\nfunction loadMapChuncks(dir) {\r\n    let geoMap = new map_1.mapLayer([], []);\r\n    fetch(dir + \"/meta.json\").then(file => file.json().then(meta => {\r\n        for (let i = 0; i < meta.count; i++) {\r\n            addMapJson(dir + \"/\" + i + \".json\", geoMap);\r\n        }\r\n    }));\r\n    return geoMap;\r\n}\r\nexports.loadMapChuncks = loadMapChuncks;\r\nasync function addMapJson(path, target) {\r\n    return new Promise(resolve => {\r\n        parseMapJson(path).then(mapData => {\r\n            let time1 = performance.now();\r\n            target.addFeatures(mapData.points, mapData.ids);\r\n            main_1.invalidate();\r\n            console.log(`Adding ${mapData.ids.length} features took ${performance.now() - time1} ms`);\r\n        });\r\n    });\r\n}\r\n\n\n//# sourceURL=webpack:///./ts/mapLoad.ts?");

/***/ }),

/***/ "./ts/memory.ts":
/*!**********************!*\
  !*** ./ts/memory.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst main_1 = __webpack_require__(/*! ./main */ \"./ts/main.ts\");\r\nconst growthRatio = 1.1;\r\nconst preallocatedSize = 0;\r\nclass GPUBufferSet {\r\n    constructor(elementWidths, buffers, size, head = 0) {\r\n        this.lockDepth = 0;\r\n        elementWidths.forEach(ele => {\r\n            if (ele % 4) {\r\n                console.warn(\"The Index Width supplied was not a multipule of 4, element widths are in bytes\");\r\n            }\r\n        });\r\n        this.buffers = [];\r\n        for (let i = 0; i < elementWidths.length; i++) {\r\n            this.buffers.push({ byteSize: elementWidths[i], buffer: buffers[i] });\r\n        }\r\n        this.bufferSize = size;\r\n        this.holes = new Map();\r\n        this.head = head;\r\n        this.bufferDeleteQueue = [];\r\n    }\r\n    static create(elementWidths) {\r\n        let buffers = elementWidths.map(byteSize => {\r\n            let buffer = main_1.gl.createBuffer();\r\n            main_1.gl.bindBuffer(main_1.gl.ARRAY_BUFFER, buffer);\r\n            main_1.gl.bufferData(main_1.gl.ARRAY_BUFFER, preallocatedSize * byteSize, main_1.gl.STATIC_DRAW);\r\n            return buffer;\r\n        });\r\n        return new GPUBufferSet(elementWidths, buffers, preallocatedSize);\r\n    }\r\n    static createFromSize(elementWidths, size) {\r\n        let buffers = elementWidths.map(byteSize => {\r\n            let buffer = main_1.gl.createBuffer();\r\n            main_1.gl.bindBuffer(main_1.gl.ARRAY_BUFFER, buffer);\r\n            main_1.gl.bufferData(main_1.gl.ARRAY_BUFFER, size * byteSize, main_1.gl.STATIC_DRAW);\r\n            return buffer;\r\n        });\r\n        return new GPUBufferSet(elementWidths, buffers, size);\r\n    }\r\n    static createFromBuffers(elementWidths, buffers, size) {\r\n        return new GPUBufferSet(elementWidths, buffers, size, size);\r\n    }\r\n    destructiveConcat(source) {\r\n        if (this.head + source.head > this.bufferSize) {\r\n            this.reallocateBuffers(this.head + source.head);\r\n        }\r\n        for (let i = 0; i < this.buffers.length; i++) {\r\n            main_1.gl.bindBuffer(main_1.gl.COPY_READ_BUFFER, source.buffers[i].buffer);\r\n            main_1.gl.bindBuffer(main_1.gl.COPY_WRITE_BUFFER, this.buffers[i].buffer);\r\n            main_1.gl.copyBufferSubData(main_1.gl.COPY_READ_BUFFER, main_1.gl.COPY_WRITE_BUFFER, 0, this.head, source.head * source.buffers[i].byteSize);\r\n            source.deleteBuffer(source.buffers[i].buffer);\r\n            source.buffers[i].buffer = null;\r\n        }\r\n        source.holes.forEach((offsets, width) => {\r\n            let bucket = this.holes.get(width);\r\n            if (!bucket) {\r\n                this.holes.set(width, []);\r\n                bucket = this.holes.get(width);\r\n            }\r\n            offsets.forEach(offset => {\r\n                bucket.push(offset + this.head);\r\n            });\r\n        });\r\n        this.head += source.head;\r\n        source.freeGPUMemory();\r\n    }\r\n    freeGPUMemory() {\r\n        if (this.lockDepth === 0) {\r\n            this.bufferDeleteQueue.forEach(buffer => {\r\n                main_1.gl.deleteBuffer(buffer);\r\n            });\r\n            this.bufferDeleteQueue = [];\r\n        }\r\n        else {\r\n            setTimeout(() => this.freeGPUMemory(), 100);\r\n            console.warn(\"GPU memory in use, trying again in 100ms\");\r\n        }\r\n    }\r\n    remove(location) {\r\n        this.zeroMemory(location);\r\n        if (this.head == location.GPUWidth + location.GPUOffset) {\r\n            this.head -= location.GPUWidth;\r\n        }\r\n        else {\r\n            let holeArray = this.holes.get(location.GPUWidth);\r\n            if (holeArray) {\r\n                holeArray.push(location.GPUOffset);\r\n            }\r\n            else {\r\n                this.holes.set(location.GPUWidth, [location.GPUOffset]);\r\n            }\r\n        }\r\n        location.GPUOffset = -1;\r\n    }\r\n    removeArray(locations) {\r\n        locations.forEach(location => this.remove(location));\r\n    }\r\n    add(location) {\r\n        if (location.GPUOffset != -1) {\r\n            throw (\"location alredy added\");\r\n        }\r\n        let swapLocation = this.holes.get(location.GPUWidth);\r\n        if (swapLocation && swapLocation.length) {\r\n            this.fillHole(swapLocation.pop(), location);\r\n        }\r\n        else {\r\n            location.GPUOffset = this.head;\r\n            this.head += location.GPUWidth;\r\n            this.putMemory(location);\r\n        }\r\n    }\r\n    addArray(locations) {\r\n        let unifiedWidth = locations.reduce((accumulator, location) => accumulator + location.GPUWidth, 0);\r\n        let insertHead;\r\n        let swapLocation = this.holes.get(unifiedWidth);\r\n        if (swapLocation && swapLocation.length) {\r\n            insertHead = swapLocation.pop();\r\n        }\r\n        else {\r\n            insertHead = this.head;\r\n            this.head += unifiedWidth;\r\n        }\r\n        let localHead = 0;\r\n        locations.forEach(location => {\r\n            location.GPUOffset = localHead + insertHead;\r\n            localHead += location.GPUWidth;\r\n        });\r\n        let unifiedArrays = [];\r\n        for (let i = 0; i < locations[0].GPUData.length; i++) {\r\n            let attribArray;\r\n            if (locations[0].GPUData[i] instanceof Float32Array) {\r\n                attribArray = new Float32Array(unifiedWidth * this.buffers[i].byteSize / 4);\r\n            }\r\n            if (locations[0].GPUData[i] instanceof Int32Array) {\r\n                attribArray = new Int32Array(unifiedWidth * this.buffers[i].byteSize / 4);\r\n            }\r\n            let offset = 0;\r\n            locations.forEach(location => {\r\n                attribArray.set(location.GPUData[i], offset);\r\n                offset += location.GPUData[i].length;\r\n            });\r\n            unifiedArrays.push(attribArray);\r\n        }\r\n        this.putMemoryChunck(insertHead, unifiedWidth, unifiedArrays);\r\n    }\r\n    addRaw(data) {\r\n        let width = 4 * data[0].length / this.buffers[0].byteSize;\r\n        this.putMemoryChunck(this.head, width, data);\r\n        this.head += width;\r\n        return new GPUMemoryPointer(this.head - width, width);\r\n    }\r\n    update(location, attribute) {\r\n        if (typeof attribute === \"number\") {\r\n            main_1.gl.bindBuffer(main_1.gl.ARRAY_BUFFER, this.buffers[attribute].buffer);\r\n            main_1.gl.bufferSubData(main_1.gl.ARRAY_BUFFER, location.GPUOffset * this.buffers[attribute].byteSize, location.GPUData[attribute]);\r\n        }\r\n        else {\r\n            this.putMemory(location);\r\n        }\r\n    }\r\n    lock() {\r\n        this.lockDepth++;\r\n    }\r\n    unlock() {\r\n        this.lockDepth--;\r\n        if (this.lockDepth == 0) {\r\n            this.bufferDeleteQueue.forEach(buffer => {\r\n                main_1.gl.deleteBuffer(buffer);\r\n            });\r\n            this.bufferDeleteQueue = [];\r\n        }\r\n    }\r\n    reallocateBuffers(minSize) {\r\n        this.resizeBuffers(Math.max(Math.floor(this.bufferSize * growthRatio), minSize));\r\n    }\r\n    resizeBuffers(size) {\r\n        this.buffers.forEach(buffer => {\r\n            let newBuffer = main_1.gl.createBuffer();\r\n            main_1.gl.bindBuffer(main_1.gl.COPY_WRITE_BUFFER, newBuffer);\r\n            main_1.gl.bufferData(main_1.gl.COPY_WRITE_BUFFER, size * buffer.byteSize, main_1.gl.STATIC_COPY);\r\n            main_1.gl.bindBuffer(main_1.gl.COPY_READ_BUFFER, buffer.buffer);\r\n            main_1.gl.copyBufferSubData(main_1.gl.COPY_READ_BUFFER, main_1.gl.COPY_WRITE_BUFFER, 0, 0, this.bufferSize * buffer.byteSize);\r\n            this.deleteBuffer(buffer.buffer);\r\n            buffer.buffer = newBuffer;\r\n        });\r\n        this.bufferSize = size;\r\n    }\r\n    deleteBuffer(buffer) {\r\n        if (this.lockDepth) {\r\n            this.bufferDeleteQueue.push(buffer);\r\n        }\r\n        else {\r\n            main_1.gl.deleteBuffer(buffer);\r\n        }\r\n    }\r\n    zeroMemory(location) {\r\n        this.buffers.forEach(buffer => {\r\n            let clearMemory = new Float32Array(location.GPUWidth * buffer.byteSize / 4);\r\n            main_1.gl.bindBuffer(main_1.gl.ARRAY_BUFFER, buffer.buffer);\r\n            main_1.gl.bufferSubData(main_1.gl.ARRAY_BUFFER, buffer.byteSize * location.GPUOffset, clearMemory);\r\n        });\r\n    }\r\n    putMemory(memory) {\r\n        this.putMemoryChunck(memory.GPUOffset, memory.GPUWidth, memory.GPUData);\r\n    }\r\n    putMemoryChunck(offset, width, data) {\r\n        while (offset + width > this.bufferSize) {\r\n            this.reallocateBuffers(offset + width);\r\n        }\r\n        for (let i = 0; i < this.buffers.length; i++) {\r\n            main_1.gl.bindBuffer(main_1.gl.ARRAY_BUFFER, this.buffers[i].buffer);\r\n            main_1.gl.bufferSubData(main_1.gl.ARRAY_BUFFER, this.buffers[i].byteSize * offset, data[i]);\r\n        }\r\n    }\r\n    fillHole(hole, replace) {\r\n        replace.GPUOffset = hole;\r\n        this.putMemory(replace);\r\n    }\r\n    swap(m1, m2) {\r\n        if (m1.GPUWidth != m2.GPUWidth) {\r\n            throw (\"incompatable widths\");\r\n        }\r\n        let otherOffset = m2.GPUOffset;\r\n        m2.GPUOffset = m1.GPUOffset;\r\n        m1.GPUOffset = otherOffset;\r\n        this.putMemory(m1);\r\n        this.putMemory(m2);\r\n    }\r\n}\r\nexports.GPUBufferSet = GPUBufferSet;\r\nclass GPUMemoryPointer {\r\n    constructor(offset, width) {\r\n        this.GPUOffset = offset;\r\n        this.GPUWidth = width;\r\n    }\r\n    toMemoryObject(data) {\r\n        let obj = new GPUMemoryObject(this.GPUWidth, data);\r\n        obj.GPUOffset = this.GPUOffset;\r\n        return obj;\r\n    }\r\n}\r\nexports.GPUMemoryPointer = GPUMemoryPointer;\r\nclass GPUMemoryObject {\r\n    constructor(width, data) {\r\n        this.GPUWidth = width;\r\n        this.GPUData = data;\r\n    }\r\n}\r\nexports.GPUMemoryObject = GPUMemoryObject;\r\n\n\n//# sourceURL=webpack:///./ts/memory.ts?");

/***/ }),

/***/ "./ts/renderer.ts":
/*!************************!*\
  !*** ./ts/renderer.ts ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result[\"default\"] = mod;\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst shaders = __importStar(__webpack_require__(/*! ./shaders.json */ \"./ts/shaders.json\"));\r\nclass ShaderProgram {\r\n    constructor(program, attributeLocations, uniformLocations) {\r\n        this.program = program;\r\n        this.attribLocations = attributeLocations;\r\n        this.uniformLocations = uniformLocations;\r\n    }\r\n}\r\nclass mapRenderer {\r\n    constructor(gl) {\r\n        this.gl = gl;\r\n        this.gl.enable(this.gl.DEPTH_TEST);\r\n        this.gl.depthFunc(this.gl.LEQUAL);\r\n        this.gl.clearColor(0, 0, 0, 1);\r\n        this.gl.clearDepth(1);\r\n        this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);\r\n        this.polyProgam = this.initShaderProgram(shaders.polygon);\r\n        this.outlineProgram = this.initShaderProgram(shaders.outline);\r\n        this.styleTransitionBoundry = { min: 30, max: 60 };\r\n    }\r\n    setTransitionBoundry(min, max) {\r\n        this.styleTransitionBoundry = { min, max };\r\n    }\r\n    getTransitionScalar(viewMatrix) {\r\n        return Math.min(Math.max((viewMatrix[4] - this.styleTransitionBoundry.min) / (this.styleTransitionBoundry.max - this.styleTransitionBoundry.min), 0), 1);\r\n    }\r\n    renderMap(map, viewMatrix, poly, outline) {\r\n        if (poly && map.polygons.head)\r\n            this.renderPolygon2dFromBuffer(map.polygons, viewMatrix);\r\n        if (outline && map.polygons.head)\r\n            this.renderOutline2dFromBuffer(map.outlines, viewMatrix);\r\n    }\r\n    renderLine2d(vertexBuffer, colorBuffer, length, viewMatrix) {\r\n        this.gl.useProgram(this.polyProgam.program);\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vertexBuffer);\r\n        this.gl.enableVertexAttribArray(this.polyProgam.attribLocations.get(\"vertexPosition\"));\r\n        this.gl.vertexAttribPointer(this.polyProgam.attribLocations.get(\"vertexPosition\"), 2, this.gl.FLOAT, false, 0, 0);\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, colorBuffer);\r\n        this.gl.enableVertexAttribArray(this.polyProgam.attribLocations.get(\"vertexColor\"));\r\n        this.gl.vertexAttribPointer(this.polyProgam.attribLocations.get(\"vertexColor\"), 3, this.gl.FLOAT, false, 0, 0);\r\n        this.gl.uniformMatrix3fv(this.polyProgam.uniformLocations.get(\"VIEW\"), false, viewMatrix);\r\n        this.gl.drawArrays(this.gl.LINES, 0, length);\r\n    }\r\n    renderLine2dFromBuffer(bufferset, viewMatrix) {\r\n        this.renderLine2d(bufferset.buffers[0].buffer, bufferset.buffers[1].buffer, bufferset.head, viewMatrix);\r\n    }\r\n    renderPolygon2d(vertexBuffer, styleBuffer, length, viewMatrix, drawMode = this.gl.TRIANGLES) {\r\n        this.gl.useProgram(this.polyProgam.program);\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vertexBuffer);\r\n        this.gl.enableVertexAttribArray(this.polyProgam.attribLocations.get(\"vertexPosition\"));\r\n        this.gl.vertexAttribPointer(this.polyProgam.attribLocations.get(\"vertexPosition\"), 2, this.gl.FLOAT, false, 0, 0);\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, styleBuffer);\r\n        this.gl.enableVertexAttribArray(this.polyProgam.attribLocations.get(\"vertexStyle\"));\r\n        this.gl.vertexAttribIPointer(this.polyProgam.attribLocations.get(\"vertexStyle\"), 1, this.gl.INT, 0, 0);\r\n        let styledata1 = new Float32Array([0.2, 0.2, 0.2, 0, 0, 1, 1, 0, 1, 0, 1, 0]);\r\n        let styledata2 = new Float32Array([0.6, 0.6, 0.6, 0, 1, 0, 1, 0, 1, 0, 0, 0]);\r\n        let styleScalar = this.getTransitionScalar(viewMatrix);\r\n        this.gl.uniform1f(this.polyProgam.uniformLocations.get(\"STYLESCALAR\"), styleScalar);\r\n        this.gl.uniform1f(this.polyProgam.uniformLocations.get(\"ZOOMLEVEL\"), viewMatrix[0]);\r\n        this.gl.uniform1f(this.polyProgam.uniformLocations.get(\"RENDERHEIGHT\"), this.gl.canvas.height);\r\n        this.gl.uniform4fv(this.polyProgam.uniformLocations.get(\"STYLETABLE1\"), styledata1);\r\n        this.gl.uniform4fv(this.polyProgam.uniformLocations.get(\"STYLETABLE2\"), styledata2);\r\n        this.gl.uniformMatrix3fv(this.polyProgam.uniformLocations.get(\"VIEW\"), false, viewMatrix);\r\n        this.gl.drawArrays(drawMode, 0, length);\r\n    }\r\n    renderPolygon2dFromBuffer(bufferSet, viewMatrix) {\r\n        bufferSet.lock();\r\n        this.renderPolygon2d(bufferSet.buffers[0].buffer, bufferSet.buffers[1].buffer, bufferSet.head, viewMatrix);\r\n        setTimeout(() => bufferSet.unlock(), 40000);\r\n    }\r\n    renderOutline2d(vertexBuffer, normalBuffer, styleBuffer, length, viewMatrix) {\r\n        let drawMode = this.gl.TRIANGLE_STRIP;\r\n        this.gl.useProgram(this.outlineProgram.program);\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vertexBuffer);\r\n        this.gl.enableVertexAttribArray(this.outlineProgram.attribLocations.get(\"vertexPosition\"));\r\n        this.gl.vertexAttribPointer(this.outlineProgram.attribLocations.get(\"vertexPosition\"), 2, this.gl.FLOAT, false, 0, 0);\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, normalBuffer);\r\n        this.gl.enableVertexAttribArray(this.outlineProgram.attribLocations.get(\"vertexNormal\"));\r\n        this.gl.vertexAttribPointer(this.outlineProgram.attribLocations.get(\"vertexNormal\"), 2, this.gl.FLOAT, false, 0, 0);\r\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, styleBuffer);\r\n        this.gl.enableVertexAttribArray(this.outlineProgram.attribLocations.get(\"vertexStyle\"));\r\n        this.gl.vertexAttribIPointer(this.outlineProgram.attribLocations.get(\"vertexStyle\"), 1, this.gl.INT, 0, 0);\r\n        let styledata1 = new Int32Array([1, 0, 0, 3, 0, 1, 0, 3, 0, 0, 1, 20]);\r\n        let styledata2 = new Int32Array([1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0]);\r\n        let styleScalar = this.getTransitionScalar(viewMatrix);\r\n        this.gl.uniform1f(this.outlineProgram.uniformLocations.get(\"STYLESCALAR\"), styleScalar);\r\n        this.gl.uniform1f(this.outlineProgram.uniformLocations.get(\"ZOOMLEVEL\"), viewMatrix[0]);\r\n        this.gl.uniform1f(this.outlineProgram.uniformLocations.get(\"RENDERHEIGHT\"), this.gl.canvas.height);\r\n        this.gl.uniform4fv(this.outlineProgram.uniformLocations.get(\"STYLETABLE1\"), styledata1);\r\n        this.gl.uniform4fv(this.outlineProgram.uniformLocations.get(\"STYLETABLE2\"), styledata2);\r\n        this.gl.uniformMatrix3fv(this.outlineProgram.uniformLocations.get(\"VIEW\"), false, viewMatrix);\r\n        this.gl.drawArrays(drawMode, 0, length);\r\n    }\r\n    renderOutline2dFromBuffer(bufferSet, viewMatrix) {\r\n        bufferSet.lock();\r\n        this.renderOutline2d(bufferSet.buffers[0].buffer, bufferSet.buffers[1].buffer, bufferSet.buffers[2].buffer, bufferSet.head, viewMatrix);\r\n        setTimeout(() => bufferSet.unlock(), 40000);\r\n    }\r\n    clear() {\r\n        this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);\r\n    }\r\n    initShaderProgram(shaderSource) {\r\n        const vertexShader = this.loadShader(this.gl.VERTEX_SHADER, shaderSource.vertex);\r\n        const fragmentShader = this.loadShader(this.gl.FRAGMENT_SHADER, shaderSource.fragment);\r\n        const glShader = this.gl.createProgram();\r\n        this.gl.attachShader(glShader, vertexShader);\r\n        this.gl.attachShader(glShader, fragmentShader);\r\n        this.gl.linkProgram(glShader);\r\n        if (!this.gl.getProgramParameter(glShader, this.gl.LINK_STATUS)) {\r\n            alert('Unable to initialize the shader program: ' + this.gl.getProgramInfoLog(glShader));\r\n            return null;\r\n        }\r\n        let attribLocations = new Map();\r\n        shaderSource.attributes.forEach(attribute => attribLocations.set(attribute, this.gl.getAttribLocation(glShader, attribute)));\r\n        let uniformLocations = new Map();\r\n        shaderSource.uniforms.forEach(uniform => uniformLocations.set(uniform, this.gl.getUniformLocation(glShader, uniform)));\r\n        return new ShaderProgram(glShader, attribLocations, uniformLocations);\r\n    }\r\n    loadShader(type, source) {\r\n        const shader = this.gl.createShader(type);\r\n        this.gl.shaderSource(shader, source);\r\n        this.gl.compileShader(shader);\r\n        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {\r\n            alert('An error occurred compiling the shaders: ' + this.gl.getShaderInfoLog(shader));\r\n            this.gl.deleteShader(shader);\r\n            return null;\r\n        }\r\n        return shader;\r\n    }\r\n}\r\nexports.mapRenderer = mapRenderer;\r\n\n\n//# sourceURL=webpack:///./ts/renderer.ts?");

/***/ }),

/***/ "./ts/shaders.json":
/*!*************************!*\
  !*** ./ts/shaders.json ***!
  \*************************/
/*! exports provided: polygon, outline, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"polygon\\\":{\\\"type\\\":\\\"Polygon\\\",\\\"fragment\\\":\\\"#version 300 es\\\\r\\\\n\\\\r\\\\nin lowp vec3 fragColor;\\\\r\\\\nout lowp vec3 color;\\\\r\\\\n\\\\r\\\\nvoid main(){\\\\r\\\\n    color = fragColor;\\\\r\\\\n}\\\",\\\"vertex\\\":\\\"#version 300 es\\\\r\\\\n\\\\r\\\\nin vec2 vertexPosition;\\\\r\\\\nin int vertexStyle;\\\\r\\\\n\\\\r\\\\nuniform vec4[128] STYLETABLE1;\\\\r\\\\nuniform vec4[128] STYLETABLE2;\\\\r\\\\nuniform mat3 VIEW;\\\\r\\\\nuniform float STYLESCALAR;\\\\r\\\\nuniform float ZOOMLEVEL;\\\\r\\\\nuniform float RENDERHEIGHT;\\\\r\\\\n\\\\r\\\\nout vec3 fragColor;\\\\r\\\\n\\\\r\\\\nvoid main(){\\\\r\\\\n    vec4 style = STYLETABLE1[vertexStyle] * STYLESCALAR + STYLETABLE2[vertexStyle] * (1.f-STYLESCALAR);\\\\r\\\\n    vec3 transforedPosition = VIEW * vec3(vertexPosition.x, vertexPosition.y, 1);\\\\r\\\\n    gl_Position = vec4(transforedPosition, 1);\\\\r\\\\n    fragColor = style.xyz;\\\\r\\\\n}\\\",\\\"attributes\\\":[\\\"vertexPosition\\\",\\\"vertexStyle\\\"],\\\"uniforms\\\":[\\\"STYLETABLE1\\\",\\\"STYLETABLE2\\\",\\\"VIEW\\\",\\\"STYLESCALAR\\\",\\\"ZOOMLEVEL\\\",\\\"RENDERHEIGHT\\\"]},\\\"outline\\\":{\\\"type\\\":\\\"Outline\\\",\\\"fragment\\\":\\\"#version 300 es\\\\r\\\\n\\\\r\\\\nin lowp vec3 fragColor;\\\\r\\\\nout lowp vec3 color;\\\\r\\\\n\\\\r\\\\nvoid main(){\\\\r\\\\n    color = fragColor;\\\\r\\\\n}\\\",\\\"vertex\\\":\\\"#version 300 es\\\\r\\\\n\\\\r\\\\nin vec2 vertexPosition;\\\\r\\\\nin vec2 vertexNormal;\\\\r\\\\nin int vertexStyle;\\\\r\\\\n\\\\r\\\\nuniform vec4[128] STYLETABLE1;\\\\r\\\\nuniform vec4[128] STYLETABLE2;\\\\r\\\\nuniform mat3 VIEW;\\\\r\\\\nuniform float STYLESCALAR;\\\\r\\\\nuniform float ZOOMLEVEL;\\\\r\\\\nuniform float RENDERHEIGHT;\\\\r\\\\n\\\\r\\\\nout vec3 fragColor;\\\\r\\\\n\\\\r\\\\nvoid main(){\\\\r\\\\n    vec4 style = STYLETABLE1[vertexStyle] * STYLESCALAR + STYLETABLE2[vertexStyle] * (1.f-STYLESCALAR);\\\\r\\\\n    float thickness = style.w / RENDERHEIGHT / ZOOMLEVEL;\\\\r\\\\n    vec3 transforedPosition = VIEW * vec3(vertexPosition.x + vertexNormal.x * thickness, vertexPosition.y + vertexNormal.y * thickness, 1);\\\\r\\\\n    gl_Position = vec4(transforedPosition, 1);\\\\r\\\\n    fragColor = style.xyz;\\\\r\\\\n}\\\",\\\"attributes\\\":[\\\"vertexPosition\\\",\\\"vertexNormal\\\",\\\"vertexStyle\\\"],\\\"uniforms\\\":[\\\"STYLETABLE1\\\",\\\"STYLETABLE2\\\",\\\"VIEW\\\",\\\"STYLESCALAR\\\",\\\"ZOOMLEVEL\\\",\\\"RENDERHEIGHT\\\"]}}\");\n\n//# sourceURL=webpack:///./ts/shaders.json?");

/***/ })

/******/ });